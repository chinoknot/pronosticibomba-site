<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Storico ROI – Pronostici Bomba</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050816;
      --bg-soft: #0f172a;
      --card: #020617;
      --accent: #f97316;
      --accent-soft: rgba(249, 115, 22, 0.18);
      --border: rgba(148, 163, 184, 0.2);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --text-soft: #6b7280;
      --accent-strong: #fb923c;
      --shadow-soft: 0 20px 45px rgba(15, 23, 42, 0.95);
      --danger: #f97373;
      --success: #4ade80;
      --pending: #eab308;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.18), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(249, 115, 22, 0.18), transparent 60%),
                  #020617;
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Inter", sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    body {
      min-height: 100vh;
      padding: 20px 10px 32px;
      display: flex;
      justify-content: center;
    }

    main {
      width: 100%;
      max-width: 1100px;
    }

    header {
      margin-bottom: 14px;
    }

    .title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 4px;
    }

    h1 {
      font-size: 1.35rem;
      font-weight: 650;
      letter-spacing: 0.03em;
    }

    .back-link {
      font-size: 0.8rem;
      color: var(--text-muted);
      text-decoration: none;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
    }

    .back-link:hover {
      border-color: rgba(248, 250, 252, 0.6);
      color: #e5e7eb;
    }

    .subtitle {
      font-size: 0.86rem;
      color: var(--text-soft);
      max-width: 720px;
      line-height: 1.5;
    }

    .controls-row {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      font-size: 0.82rem;
      color: var(--text-muted);
    }

    .range-fixed-pill {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      font-size: 0.78rem;
      color: var(--text-main);
    }

    .range-label {
      font-weight: 500;
    }

    .summary-card {
      margin-top: 14px;
      margin-bottom: 14px;
      padding: 12px 12px;
      border-radius: 18px;
      background: radial-gradient(circle at top right, rgba(37, 99, 235, 0.28), transparent 65%),
                  linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(2, 6, 23, 0.98));
      border: 1px solid rgba(37, 99, 235, 0.5);
      box-shadow: var(--shadow-soft);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 8px;
      font-size: 0.82rem;
    }

    .summary-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .summary-label {
      font-size: 0.78rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .summary-value {
      font-size: 1rem;
      font-weight: 600;
    }

    .summary-value-small {
      font-size: 0.86rem;
      font-weight: 500;
    }

    .badge-pos {
      color: #bbf7d0;
    }

    .badge-neg {
      color: #fecaca;
    }

    .badge-neutral {
      color: var(--text-main);
    }

    .section-title {
      margin-top: 24px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      color: var(--text-muted);
      font-weight: 500;
    }

    .table-wrapper {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      border: 1px solid rgba(30, 64, 175, 0.4);
      box-shadow: var(--shadow-soft);
      padding: 12px 10px 10px;
      margin-bottom: 18px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.82rem;
      min-width: 600px;
    }

    thead {
      background: rgba(15, 23, 42, 0.9);
    }

    th, td {
      padding: 6px 8px;
      text-align: left;
      border-bottom: 1px solid rgba(30, 64, 175, 0.3);
      white-space: nowrap;
    }

    th {
      font-weight: 500;
      color: var(--text-muted);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.9);
    }

    tbody tr:hover {
      background: rgba(30, 64, 175, 0.35);
    }

    td {
      font-size: 0.8rem;
    }

    .empty {
      font-size: 0.85rem;
      color: var(--text-muted);
      padding: 6px 4px;
    }

    .info-block {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 0.82rem;
      color: var(--text-soft);
    }

    .info-title {
      font-weight: 600;
      margin-bottom: 6px;
    }

    .info-list {
      list-style: disc;
      padding-left: 16px;
      margin-top: 4px;
    }

    .info-list li {
      margin-bottom: 4px;
    }

    .info-list strong {
      color: #e5e7eb;
    }

    @media (max-width: 720px) {
      body {
        padding: 12px 6px 24px;
      }

      .summary-card {
        border-radius: 14px;
      }

      .table-wrapper {
        border-radius: 14px;
      }

      table {
        font-size: 0.78rem;
      }

      th, td {
        padding: 6px;
      }
    }

    @media (max-width: 560px) {
      table, thead, tbody, th, td, tr {
        display: block;
      }

      thead {
        display: none;
      }

      table {
        min-width: 0;
      }

      tr {
        margin-bottom: 10px;
        border-radius: 10px;
        border: 1px solid rgba(30, 64, 175, 0.5);
        overflow: hidden;
      }

      td {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        padding: 4px 4px;
        font-size: 0.8rem;
      }

      td::before {
        content: attr(data-label);
        font-weight: 500;
        color: var(--text-muted);
        margin-right: 8px;
        text-transform: none;
        letter-spacing: 0;
        font-size: 0.78rem;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <div class="title-row">
        <h1>Storico ROI</h1>
        <a href="/index.html" class="back-link">← Torna ai pronostici di oggi</a>
      </div>
      <p class="subtitle">
        Qui trovi il rendimento storico con stake fisso 1 unità,
        calcolato <strong>per evento</strong>: ogni partita (fixture_id) conta una sola volta (stake 1),
        scegliendo la pick risolta con score più alto.
        Il ROI e il profitto sono calcolati solo sulle righe con esito WIN/LOSE; le quote
        sono quelle mostrate al momento della generazione.
      </p>

      <div class="controls-row">
        <span class="range-label">Intervallo analizzato</span>
        <span class="range-fixed-pill">Ultimi 30 giorni (fisso)</span>
      </div>
    </header>

    <section class="summary-card">
      <div class="summary-item">
        <span class="summary-label">ROI totale</span>
        <span id="summary-roi" class="summary-value badge-neutral">-</span>
        <span id="summary-profit" class="summary-value-small badge-neutral">-</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Periodo coperto</span>
        <span id="summary-period" class="summary-value-small">-</span>
        <span id="summary-days" class="summary-value-small" style="color: var(--text-muted);">-</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Winrate & affidabilità</span>
        <span id="summary-winrate" class="summary-value badge-neutral">-</span>
        <span id="summary-wl" class="summary-value-small" style="color: var(--text-muted);">-</span>
        <span id="summary-winrate-needed" class="summary-value-small" style="color: var(--text-muted);">-</span>
        <span id="summary-reliability" class="summary-value-small badge-neutral">-</span>
      </div>
    </section>

    <h2 class="section-title">Andamento giornaliero (solo picks risolte)</h2>
    <div id="table-container"></div>

    <section class="info-block">
      <div class="info-title">Come leggere ROI, winrate e reliability</div>
      <ul class="info-list">
        <li><strong>ROI</strong>: profitto percentuale rispetto allo stake totale. Es:
          ROI 12% significa 12 unità di profitto ogni 100 giocate.</li>
        <li><strong>Winrate</strong>: percentuale di pronostici vinti sul totale
          (solo picks con esito WIN/LOSE).</li>
        <li><strong>Modalità calcolo</strong>: <strong>per evento</strong> (1 stake per partita/fixture, scegliendo la pick risolta con score più alto).</li>
        <li><strong>Quota media & winrate necessaria</strong>:
          ogni quota media ha un winrate di pareggio (break-even). Esempio:
          quota media 1.80 ⇒ winrate necessaria ≈ 55.6%.</li>
        <li><strong>Reliability</strong>:
          un indicatore qualitativo che prende in considerazione:
          <ul class="info-list">
            <li>numero di pronostici giocati (più è alto, meglio è);</li>
            <li>quanto il winrate effettivo è sopra (o sotto) il winrate di pareggio;</li>
            <li>stabilità del ROI nel periodo selezionato.</li>
          </ul>
        </li>
        <li><strong>Campione ridotto</strong>:
          se le picks sono poche, la reliability viene penalizzata.
          Se i dati sono pochi, viene mostrato <em>Dati pochi (campione ridotto)</em>.</li>
      </ul>
    </section>
  </main>

<script>
  // ===== CONFIG SUPABASE (solo lettura) =====
  const SUPABASE_URL = "https://oiudaxsyvhjpjjhglejd.supabase.co";
  const SUPABASE_ANON_KEY =
     "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9pdWRheHN5dmhqcGpqaGdsZWpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQwMDk0OTcsImV4cCI6MjA3OTU4NTQ5N30.r7kz3FdijAhsJLz1DcEtobJLaPCqygrQGgCPpSc-05A";

  // ===== ROI MODE =====
  // FISSO: SOLO "event"
  const ROI_MODE = "event";

  async function sbFetch(table, query) {
    const url = `${SUPABASE_URL}/rest/v1/${table}${query}`;
    const res = await fetch(url, {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
      },
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Supabase error ${res.status}: ${text}`);
    }
    return await res.json();
  }

  // ===== HELPER =====
  function pad2(n) {
    return n < 10 ? "0" + n : "" + n;
  }

  function formatDateIT(str) {
    if (!str) return "";
    const parts = str.split("-");
    if (parts.length !== 3) return str;
    const [y, m, d] = parts;
    return `${d}/${m}/${y}`;
  }

  function getLastNDates(n) {
    const dates = [];
    const now = new Date();
    now.setHours(0, 0, 0, 0);

    for (let i = 0; i < n; i++) {
      const d = new Date(now);
      d.setDate(now.getDate() - i);
      const y = d.getFullYear();
      const m = pad2(d.getMonth() + 1);
      const day = pad2(d.getDate());
      dates.push(`${y}-${m}-${day}`);
    }
    return dates;
  }

  function safeOdd(o) {
    const n = Number(o);
    if (!isFinite(n) || n <= 1) return 1.0;
    return n;
  }

  // ===== NOMI ELEGANTI CATEGORIE =====
  const CATEGORY_LABELS = {
    BEST_TIPS_OF_DAY: "Scelte d’Élite",
    SAFE_PICKS: "Selezioni Affidabili",
    VALUE_PICKS: "Quote di Valore",
    OVER_UNDER_TIPS: "Tendenze Goal",
    BTTS_TIPS: "Probabilità Entrambe",
    DAILY_2PLUS: "Combo Selettiva",
    DAILY_10PLUS: "Combo High Stakes",
    SINGLE_GAME: "Pick Esclusiva",
    TOP_5_TIPS: "Top 5 Esclusive",
    __PICK_ESCLUSIVA__: "Pick Esclusiva",
    DNB_ENGINE: "DNB Engine",
    HT_O0_5: "HT Over 0.5",
    HT_OVER_0_5: "HT Over 0.5",
    BTTS: "BTTS",
    BTTS_TIPS: "BTTS",
    COMBO_DOPPIA_O15: "Combo Doppia Chance + Over 1.5",
  };

  function getCategoryLabel(cat) {
    const k = normalizeCatKey(cat);
    if (k === EXCLUSIVE_AGG_KEY) return "Pick Esclusiva";
    return CATEGORY_LABELS[k] || (cat || "Altro").replace(/_/g, " ");
  }

  // categorie da NASCONDERE nella tabella "Rendimento per categoria di modello"
  const HIDDEN_CATEGORY_KEYS = new Set(["DAILY_2PLUS", "DAILY_10PLUS"]);

  
  // Categoria UI: "Pick Esclusiva"
  // In home spesso include SINGLE_GAME e (se presente) TOP_5_TIPS.
  // Per lo storico, le aggreghiamo in un'unica riga per evitare mismatch UI ↔ storico.
  const EXCLUSIVE_CATEGORY_KEYS = new Set(["SINGLE_GAME", "TOP_5_TIPS"]);
  const EXCLUSIVE_AGG_KEY = "__PICK_ESCLUSIVA__";

  function normalizeCatKey(cat) {
    const raw = (cat || "").toString().trim();
    const up = raw.toUpperCase();

    if (!up) return "";

    // Normalize common aliases to match the category keys used in the homepage (index.html)
    if (up === "GG SPECIAL" || up === "GG_SPECIAL" || up === "BTTS_TIPS" || up === "BTTS") return "BTTS";
    if (up === "HT O0.5" || up === "HT_O0_5" || up === "HT_OVER_0_5" || up === "HT OVER 0.5") return "HT_OVER_0_5";

    // Double Chance + Over 1.5 (UI: "Combo Doppia Chance + Over 1.5" / "Double Chance + Over 1.5")
    // We accept many human labels coming from the scraper / manual edits.
    if (
      up === "COMBO_DOPPIA_O15" ||
      (up.includes("DOPPIA") && (up.includes("O1.5") || up.includes("OVER 1.5") || up.includes("OVER1.5") || up.includes("OVER 1,5"))) ||
      (up.includes("DOUBLE") && up.includes("CHANCE") && (up.includes("1.5") || up.includes("1,5")))
    ) return "COMBO_DOPPIA_O15";

    return up.replace(/\s+/g, "_");
  }

// ranking dei risultati: preferiamo righe con esito definito e match finito
  function resultRank(r) {
    let score = 0;
    const res = (r.result || "").toUpperCase();
    const st = (r.status_short || "").toUpperCase();

    if (res === "WIN" || res === "LOSE") score += 4;
    else if (res === "PENDING") score += 1;

    if (["FT", "AET", "PEN"].includes(st)) score += 4;
    else if (["2H", "HT"].includes(st)) score += 2;

    if (res === "WIN") score += 2;
    if (res === "LOSE") score += 1;

    return score;
  }

  function reliabilityLabel(totalPicks, winrate, neededWinrate) {
    if (!totalPicks || !isFinite(winrate) || !isFinite(neededWinrate)) {
      return "Dati insufficienti";
    }
    const diff = winrate - neededWinrate;

    if (totalPicks < 20) {
      if (diff >= 5) return "Buona ma campione ridotto";
      if (diff >= 0) return "Ok ma campione ridotto";
      return "Dati pochi (campione ridotto)";
    }

    if (totalPicks < 50) {
      if (diff >= 5) return "Buona";
      if (diff >= 0) return "Discreta";
      if (diff >= -3) return "Debole";
      return "Negativa";
    }

    if (diff >= 7) return "Molto buona";
    if (diff >= 3) return "Buona";
    if (diff >= 0) return "Discreta";
    if (diff >= -3) return "Debole";
    return "Negativa";
  }

  async function fetchDayStats(dateStr) {
    const picks = await sbFetch(
      "picks",
      `?match_date=eq.${dateStr}&select=*`
    );

    if (!Array.isArray(picks) || picks.length === 0) {
      return {
        date: dateStr,
        wins: 0,
        loses: 0,
        stake: 0,
        profit: 0,
        avgOdd: null,
        categoryStats: {},
      };
    }

    const results = await sbFetch(
      "results",
      `?picks_date=eq.${dateStr}&select=*`
    );

    const resultMap = new Map();
    if (Array.isArray(results)) {
      for (const r of results) {
        const fid = String(r.fixture_id || "").trim();
        const pickText = String(r.pick || "").trim();
        if (!fid && !pickText) continue;
        const key = fid + "__" + pickText;

        const existing = resultMap.get(key);
        if (!existing || resultRank(r) > resultRank(existing)) {
          resultMap.set(key, r);
        }
      }
    }

    function pickResult(p) {
      const fid = String(p.fixture_id || "").trim();
      const pickText = String(p.pick || "").trim();
      const key = fid + "__" + pickText;
      const res = resultMap.get(key) || {};
      return (res.result || "").toUpperCase();
    }

    function chooseBestResolvedPick(list) {
      // Modalità "per evento": una sola pick per fixture.
      // Regola (Opzione 1):
      // - Considera solo pick RISOLTE (WIN/LOSE)
      // - Se esiste almeno una WIN, la fixture è WIN e scegliamo la WIN con score più alto (tie-break: odd)
      // - Altrimenti (solo LOSE), la fixture è LOSE e scegliamo la LOSE con score più alto (tie-break: odd)
      const resolved = list.filter(p => {
        const r = pickResult(p);
        return r === "WIN" || r === "LOSE";
      });
      if (!resolved.length) return null;

      const wins = resolved.filter(p => pickResult(p) === "WIN");
      const pool = wins.length ? wins : resolved; // se non ci sono WIN, restano solo LOSE

      pool.sort((a, b) => {
        const sa = Number(a.score || 0);
        const sb = Number(b.score || 0);
        if (sb !== sa) return sb - sa;

        const oa = safeOdd(a.odd);
        const ob = safeOdd(b.odd);
        return ob - oa;
      });

      return pool[0];
    }

    let wins = 0;
    let loses = 0;
    let stake = 0;
    let profit = 0;
    let oddsSum = 0;
    let oddsCount = 0;

    const categories = {};

    function ensureCategory(key) {
      const catKey = (key || "ALTRO").trim() || "ALTRO";
      if (!categories[catKey]) {
        categories[catKey] = { wins: 0, loses: 0, stake: 0, profit: 0, oddsSum: 0, oddsCount: 0 };
      }
      return categories[catKey];
    }

    function applyResolved(p, result) {
      const odd = safeOdd(p.odd);
      const c = ensureCategory(p.category);

      stake += 1;
      c.stake += 1;

      if (result === "WIN") {
        wins += 1;
        profit += odd - 1;
        c.wins += 1;
        c.profit += odd - 1;
      } else {
        loses += 1;
        profit -= 1;
        c.loses += 1;
        c.profit -= 1;
      }

      oddsSum += odd;
      oddsCount += 1;
      c.oddsSum += odd;
      c.oddsCount += 1;
    }

    // === SOLO modalità evento: 1 stake per fixture_id ===
    const byFixture = {};

    // Per mostrare categorie anche quando hanno solo VOID/PENDING (stake 0),
    // teniamo traccia di quante fixture hanno almeno una pick per categoria.
    const categorySeenFixtures = {};

    for (const p of picks) {
      const fid = String(p.fixture_id || "").trim();
      if (!fid) continue;
      if (!byFixture[fid]) byFixture[fid] = [];
      byFixture[fid].push(p);
    }


// Popola presence per categoria (fixture uniche)
for (const fid of Object.keys(byFixture)) {
  const cats = new Set();
  for (const p of byFixture[fid]) {
    const ck = normalizeCatKey(p.category || "ALTRO") || "ALTRO";
    cats.add(ck);
  }
  for (const ck of cats) {
    categorySeenFixtures[ck] = (categorySeenFixtures[ck] || 0) + 1;
  }
}

for (const fid of Object.keys(byFixture)) {
      const chosen = chooseBestResolvedPick(byFixture[fid]);
      if (!chosen) continue;
      const result = pickResult(chosen);
      if (result === "WIN" || result === "LOSE") {
        applyResolved(chosen, result);
      }
    }

    const avgOdd = oddsCount > 0 ? oddsSum / oddsCount : null;

    return {
      date: dateStr,
      wins,
      loses,
      stake,
      profit,
      avgOdd,
      categoryStats: categories,
      categorySeenFixtures,
    };
  }

  async function loadHistory(daysBack) {
    const tableContainer = document.getElementById("table-container");
    tableContainer.innerHTML = `
      <div class="table-wrapper">
        <div class="empty">Carico dati degli ultimi ${daysBack} giorni...</div>
      </div>
    `;

    const dates = getLastNDates(daysBack);

    try {
      const statsListRaw = await Promise.all(
        dates.map(d => fetchDayStats(d).catch(() => null))
      );

      const statsList = statsListRaw.filter(s => s && s.stake > 0);

      if (!statsList || statsList.length === 0) {
        tableContainer.innerHTML = `
          <div class="table-wrapper">
            <div class="empty">
              Nessun dato disponibile nel periodo selezionato.
            </div>
          </div>
        `;
        document.getElementById("summary-period").textContent = "-";
        document.getElementById("summary-days").textContent = "-";
        document.getElementById("summary-winrate").textContent = "-";
        document.getElementById("summary-wl").textContent = "-";
        document.getElementById("summary-roi").textContent = "-";
        document.getElementById("summary-profit").textContent = "-";
        document.getElementById("summary-winrate-needed").textContent = "-";
        document.getElementById("summary-reliability").textContent = "-";
        return;
      }

      const byDay = new Map();
      const byCategory = {};
      const byCategorySeen = {};

      let totalWins = 0;
      let totalLoses = 0;
      let totalStake = 0;
      let totalProfit = 0;
      let totalOddsSum = 0;
      let totalOddsCount = 0;

      for (const s of statsList) {
        // merge category presence (fixture uniche per giorno)
        for (const [catKey, cnt] of Object.entries(s.categorySeenFixtures || {})) {
          const k = normalizeCatKey(catKey) || "ALTRO";
          byCategorySeen[k] = (byCategorySeen[k] || 0) + (cnt || 0);
        }

        byDay.set(s.date, {
          wins: s.wins,
          loses: s.loses,
          stake: s.stake,
          profit: s.profit,
        });

        totalWins += s.wins;
        totalLoses += s.loses;
        totalStake += s.stake;
        totalProfit += s.profit;
        if (s.avgOdd) {
          totalOddsSum += s.avgOdd * (s.wins + s.loses);
          totalOddsCount += (s.wins + s.loses);
        }

        for (const [catKey, c] of Object.entries(s.categoryStats || {})) {
          if (!byCategory[catKey]) {
            byCategory[catKey] = {
              wins: 0,
              loses: 0,
              stake: 0,
              profit: 0,
              oddsSum: 0,
              oddsCount: 0,
            };
          }
          const dest = byCategory[catKey];
          dest.wins += c.wins || 0;
          dest.loses += c.loses || 0;
          dest.stake += c.stake || 0;
          dest.profit += c.profit || 0;
          dest.oddsSum += c.oddsSum || 0;
          dest.oddsCount += c.oddsCount || 0;
        }
      }

      

// ===== Aggregazione "Pick Esclusiva" (SINGLE_GAME + TOP_5_TIPS) =====
function mergeIntoExclusive(catKey) {
  const k = normalizeCatKey(catKey);
  const src = byCategory[k];
  if (!src) return;
  if (!byCategory[EXCLUSIVE_AGG_KEY]) {
    byCategory[EXCLUSIVE_AGG_KEY] = { wins: 0, loses: 0, stake: 0, profit: 0, oddsSum: 0, oddsCount: 0 };
  }
  const dest = byCategory[EXCLUSIVE_AGG_KEY];
  dest.wins += src.wins || 0;
  dest.loses += src.loses || 0;
  dest.stake += src.stake || 0;
  dest.profit += src.profit || 0;
  dest.oddsSum += src.oddsSum || 0;
  dest.oddsCount += src.oddsCount || 0;

  delete byCategory[k];
}

for (const k of EXCLUSIVE_CATEGORY_KEYS) {
  mergeIntoExclusive(k);
}

// presence aggregation
let exclusiveSeen = 0;
for (const k of EXCLUSIVE_CATEGORY_KEYS) {
  exclusiveSeen += (byCategorySeen[normalizeCatKey(k)] || 0);
  delete byCategorySeen[normalizeCatKey(k)];
}
if (exclusiveSeen > 0) {
  byCategorySeen[EXCLUSIVE_AGG_KEY] = (byCategorySeen[EXCLUSIVE_AGG_KEY] || 0) + exclusiveSeen;
}

const startDate = statsList[statsList.length - 1].date;
      const endDate = statsList[0].date;
      const periodLabel = `${formatDateIT(startDate)} → ${formatDateIT(endDate)}`;
      const daysEffective = statsList.length;

      document.getElementById("summary-period").textContent = periodLabel;
      document.getElementById("summary-days").textContent =
        `${daysEffective} giorni con picks giocate`;

      const totalPlayed = totalWins + totalLoses;
      const winrateTotal =
        totalPlayed > 0 ? ((totalWins / totalPlayed) * 100).toFixed(1) : "-";
      const roiTotal =
        totalStake > 0 ? ((totalProfit / totalStake) * 100).toFixed(1) : "-";
      const avgOddGlobal =
        totalOddsCount > 0 ? (totalOddsSum / totalOddsCount) : null;
      const winrateNeededGlobal =
        avgOddGlobal && avgOddGlobal > 1
          ? (100 / avgOddGlobal).toFixed(1)
          : "-";

      const roiEl = document.getElementById("summary-roi");
      const profitEl = document.getElementById("summary-profit");
      if (roiTotal === "-") {
        roiEl.textContent = "-";
        roiEl.className = "summary-value badge-neutral";
        profitEl.textContent = "-";
        profitEl.className = "summary-value-small badge-neutral";
      } else {
        roiEl.textContent = `${roiTotal}%`;
        const roiNum = parseFloat(roiTotal);
        roiEl.className =
          "summary-value " + (roiNum >= 0 ? "badge-pos" : "badge-neg");

        const profLabel =
          totalProfit >= 0
            ? `Profitto totale: +${totalProfit.toFixed(2)} unità`
            : `Profitto totale: ${totalProfit.toFixed(2)} unità`;
        profitEl.textContent = profLabel;
        profitEl.className =
          "summary-value-small " + (totalProfit >= 0 ? "badge-pos" : "badge-neg");
      }

      const wrEl = document.getElementById("summary-winrate");
      const wlEl = document.getElementById("summary-wl");
      if (winrateTotal === "-") {
        wrEl.textContent = "-";
        wrEl.className = "summary-value badge-neutral";
        wlEl.textContent = "-";
      } else {
        wrEl.textContent = `${winrateTotal}%`;
        wrEl.className = "summary-value badge-neutral";
        wlEl.textContent = `${totalWins} win / ${totalLoses} lose (solo picks con esito definito)`;
      }

      const winNeedEl = document.getElementById("summary-winrate-needed");
      if (winrateNeededGlobal === "-") {
        winNeedEl.textContent = "Winrate necessaria: -";
      } else {
        winNeedEl.textContent =
          `Winrate necessaria per break-even: ${winrateNeededGlobal}% (quota media ~ ${avgOddGlobal.toFixed(2)})`;
      }

      const relEl = document.getElementById("summary-reliability");
      if (winrateTotal === "-" || winrateNeededGlobal === "-") {
        relEl.textContent = "-";
        relEl.className = "summary-value-small badge-neutral";
      } else {
        const wrNum = parseFloat(winrateTotal);
        const needNum = parseFloat(winrateNeededGlobal);
        const label = reliabilityLabel(totalPlayed, wrNum, needNum);
        relEl.textContent = `Reliability: ${label}`;
        let cls = "badge-neutral";
        if (label.startsWith("Molto") || label.startsWith("Buona")) cls = "badge-pos";
        else if (label.startsWith("Debole") || label.startsWith("Negativa")) cls = "badge-neg";
        relEl.className = "summary-value-small " + cls;
      }

      const sortedDays = Array.from(byDay.keys()).sort().reverse();

      let html = `
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Data</th>
                <th>Picks giocate</th>
                <th>Win</th>
                <th>Lose</th>
                <th>ROI giornaliero</th>
                <th>Profitto</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (const day of sortedDays) {
        const s = byDay.get(day);
        const played = s.wins + s.loses;
        const roiDay =
          s.stake > 0 ? ((s.profit / s.stake) * 100).toFixed(1) : "-";
        const profitStr =
          s.profit >= 0 ? `+${s.profit.toFixed(2)}` : s.profit.toFixed(2);
        const roiClass =
          roiDay === "-"
            ? "badge-neutral"
            : parseFloat(roiDay) >= 0
            ? "badge-pos"
            : "badge-neg";

        html += `
          <tr>
            <td data-label="Data">${formatDateIT(day)}</td>
            <td data-label="Picks giocate">${played}</td>
            <td data-label="Win">${s.wins}</td>
            <td data-label="Lose">${s.loses}</td>
            <td data-label="ROI giornaliero" class="${roiClass}">
              ${roiDay === "-" ? "-" : roiDay + "%"}
            </td>
            <td data-label="Profitto">${profitStr} u</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      // ===== RENDIMENTO PER CATEGORIA (con filtro richiesto) =====
      const catKeysAll = Array.from(new Set([...Object.keys(byCategory), ...Object.keys(byCategorySeen)]));
      const catKeys = catKeysAll.filter(k => !HIDDEN_CATEGORY_KEYS.has(String(k || "").toUpperCase()));

      if (catKeys.length) {
        html += `
          <div class="table-wrapper">
            <h2 class="section-title">Rendimento per categoria di modello</h2>
            <table>
              <thead>
                <tr>
                  <th>Categoria</th>
                  <th>Picks giocate</th>
                  <th>Win</th>
                  <th>Lose</th>
                  <th>Winrate</th>
                  <th>ROI (stake=1)</th>
                  <th>Quota media</th>
                  <th>Winrate pareggio</th>
                  <th>Reliability</th>
                </tr>
              </thead>
              <tbody>
        `;

        for (const catKey of catKeys) {
          const c = byCategory[catKey] || { wins: 0, loses: 0, stake: 0, profit: 0, oddsSum: 0, oddsCount: 0 };
          const seen = byCategorySeen[normalizeCatKey(catKey)] || byCategorySeen[catKey] || 0;
          const playedCat = c.wins + c.loses;
          const winrateCat =
            playedCat > 0 ? ((c.wins / playedCat) * 100).toFixed(1) : "-";
          const roiCat =
            c.stake > 0
              ? ((c.profit / c.stake) * 100).toFixed(1)
              : "-";
          const avgOdd =
            c.oddsCount > 0
              ? (c.oddsSum / c.oddsCount)
              : null;
          const avgOddStr = avgOdd ? avgOdd.toFixed(2) : "-";
          const winNeedCat =
            avgOdd && avgOdd > 1
              ? (100 / avgOdd).toFixed(1)
              : "-";

          const roiCatClass =
            roiCat === "-"
              ? "badge-neutral"
              : parseFloat(roiCat) >= 0
              ? "badge-pos"
              : "badge-neg";

          let relLabel = "-";
          if (playedCat === 0 && seen > 0) { relLabel = "Solo VOID/PENDING"; }

          let relClass = "badge-neutral";
          if (relLabel === "-" && winrateCat !== "-" && winNeedCat !== "-") {
            const wrNum = parseFloat(winrateCat);
            const needNum = parseFloat(winNeedCat);
            relLabel = reliabilityLabel(playedCat, wrNum, needNum);
            if (relLabel.startsWith("Molto") || relLabel.startsWith("Buona")) {
              relClass = "badge-pos";
            } else if (relLabel.startsWith("Debole") || relLabel.startsWith("Negativa")) {
              relClass = "badge-neg";
            }
          }

          html += `
            <tr>
              <td data-label="Categoria">${getCategoryLabel(catKey)}</td>
              <td data-label="Picks giocate">${playedCat}</td>
              <td data-label="Win">${c.wins}</td>
              <td data-label="Lose">${c.loses}</td>
              <td data-label="Winrate">${winrateCat === "-" ? "-" : winrateCat + "%"}</td>
              <td data-label="ROI" class="${roiCatClass}">${roiCat === "-" ? "-" : roiCat + "%"}</td>
              <td data-label="Quota media">${avgOddStr}</td>
              <td data-label="Winrate pareggio">${winNeedCat === "-" ? "-" : winNeedCat + "%"}</td>
              <td data-label="Reliability" class="${relClass}">${relLabel}</td>
            </tr>
          `;
        }

        html += `
              </tbody>
            </table>
          </div>
        `;
      }

      // ===== Sezione "Rendimento per fascia di confidenza modello" rimossa =====

      tableContainer.innerHTML = html;
    } catch (err) {
      console.error(err);
      tableContainer.innerHTML = `
        <div class="table-wrapper">
          <div class="empty">
            Errore nel caricamento dei dati. Riprova tra qualche minuto.
          </div>
        </div>
      `;
    }
  }

  const DAYS_FIXED = 30; // fisso, sempre 30 giorni

  document.addEventListener("DOMContentLoaded", () => {
    loadHistory(DAYS_FIXED);
  });
</script>

</body>
</html>
